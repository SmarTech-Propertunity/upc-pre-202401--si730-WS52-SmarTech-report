# Capítulo 5: Product Implementation, Validation & Deployment

## 5.1 Software Configuration Management.

Para la gestión de la configuración de software de nuestra aplicación web nos enfocaremos principalmente en la gestión de código fuente, donde controlaremos las versiones y estableceremos una estructura organizada a lo largo de todo el curso de trabajo. Aquí nos aseguramos que todos los miembros del equipo tengan herramientas consistentes para el desarrollo útil y posean una buena configuración de despliegue en el entorno de desarrollo y también ciertas caracteristicas para el entorno de producción. Esta toma de decisiones garantiza la eficiencia, comodidad y coherencia a lo largo de todo el ciclo de vida de la aplicación, lo que es obligatorio para cumplir con nuestra misión y visión y seguir todos nuestros valores y objetivos. De esta forma vamos a ofrecer a nuestro segmento objetivo un espacio seguro, formal e informado en donde buscar y adquirir propiedades para sus bienes raíces, o donde puedan ingresar y publicar las propiedades que quieren vender, junto a otro grupo de funcionalidades ya destacadas en otros capitulos de este informe.

### 5.1.1 Software Development Environment Configuration

En esta sección nuestro equipo de trabajo va a especificar, describir e indicar los nombres de productos, el propósito de uso en el proyecto, la ruta de referencia (para software basado en modelos SaaS) o ruta de descarga (para productos que se ejecutan en el computador del miembro del equipo) de cada uno de los productos de software que deben utilizar los miembros del equipo para colaborar en el ciclo de vida del producto digital, considerando todos los tipos de actividades como Project Management, Requirements Management, Product UX/UI Design, Software Development, Software Testing, Software Deployment, Software Documentation.

#### Project Management:

Esta sección respecta a la organización y control del proyecto durante todo su ciclo de vida en el sentido de control del personal que trabaja en este, junto a sus acciones y colaboraciones a lo largo del tiempo y a sus asignaciones ya estipuladas. Ante esto, hemos separado esta sección entre tres puntos distintos que funcionan como distintos métodos de comunicación y gestión del equipo de trabajo.

**Reuniones de trabajo:** Con respecto a las reuniones organizadas para el equipo de trabajo, nuestro grupo ha decidido de forma unanime que el mejor medio de reunión mediante videoconferencia era con el uso de las herramientas de la aplicación "Discord". Esto debido a que todos tenemos conocimiento sobre el uso de la aplicación y lo consideramos más cómodo y rápido en comparación de otras aplicaciones de videoconferencia. Aunque Discord no tiene las mismas herramientas que otras aplicaciones tienen, consideramos que es mejor porque mantiene un acceso y comunicación más eficiente, tiene una interfaz más simple y directa, y porque no presenta limites de tiempo durante las reuniones.

Página oficial de Discord: https://discord.com/ 

**Organización del trabajo:** Con respecto a la organización del trabajo para cada miembro del equipo, nuestro grupo a utilizado las herramientas provistas por la aplicación web "ClickUp". Esto debido a que esta aplicación permite la separación de actividades entre varios miembros de trabajo junto al uso de fechas límite, apoyos y el estado de cada actividad, juntandose en un solo organizador. ClickUp permite revisar todo el rendimiento en conjunto y las actividades realizadas por cada usuario.

Página oficial de ClickUp: https://clickup.com/ 

**Control de Versiones:** Con respecto al control de versiones que presentara nuestro equipo de trabajo, nuestro grupo a utilizado las propias herramientas de "Github" dentro de la organización de todo el proyecto. A través del uso de commits y pull request, cada miembro del equipo puede apoyar en el desarrollo y, a través del historial, revisar las antiguas versiones antes de los cambios propuestos.

---

#### Product UX/UI Design:

Esta sección respecta al desarrollo y diseñado de las secciones basadas en el UX y UI correspondientes a nuestro proyecto durante todo su ciclo de vida. Las herramientas utilizadas deben estar compuestas de varias aplicaciones con estilos varios que permitan modificar la estetica de todas las páginas que vamos a programar y como estas se verían para nuestros clientes finales, siguiendo las historias de usuario y toda metodologia de desarrollo web. Asimismo, estas herramientas también deben permitir la estructuración y diagramación de todas las tablas y organizadores necesarios.

**Mapas:** Con respecto al diseñado de todos los diagramas referentes a mapas con seguimientos, como el Empathy Map, el Journey Map y el Impact Map, hemos decidido desarrollarlos en la plataforma de "Miro", puesto que esta mantiene un estilo de diseñado mucho más cómodo en comparación con otras aplicaciones. Asimismo, permite el desarrollo en colaboración de forma rápida y precisa.

Página oficial de Miro: https://miro.com/ 

**User Personas:** Con respecto al diseñado de nuestros User Persona para cada segmento objetivo identificado para nuestra startup y nuestro producto, hemos decidido desarrollarlos en la plataforma de "UXPressia", puesto que esta posee herramientas que, aunque no son muy cómodas en el desarrollo de gráficos grandes y diagramas, sí mantiene formatos agradables con modelos ya realizados con los que guiarnos para nuestros User Persona.

Página oficial de UXPressia: https://uxpressia.com/ 

**Wireframes, Mock-ups y Prototypes:** Con respecto al diseñado de los wireframes y mock-ups referentes a la landing page de nuestra startup junto a todas las pestañas de la aplicación web con sus modelos de Responsive Design y a los modelos especializados para los Prototypes, nuestro grupo ha decidido utilizar la plataforma de "Figma", la cual esta especializada en el diseño de aplicaciones y páginas web junto a la forma en la que se verían para nuestros clientes, además de realizar un seguimiento entre cada página. Asimismo, permite el desarrollo colaborativo y ya trae muchos modelos para landing page y aplicaciones que nuestro equipo puede usar para guiarse.

Página oficial de Figma: https://figma.com/ 

---

#### Product Architecture Design:

Esta sección respecta al desarrollo y diseñado de las secciones basadas en la arquitectura del producto durante todo su ciclo de vida. Las herramientas utilizadas deben estar compuestas de varias aplicaciones con estilos varios que permitan la diagramación de esquemas complejos y completos sobre cada una de las capas de la arquitectura que mostrara nuestra solución, identificando todos sus componentes junto a los framework, IDEs y lenguajes de programación a utilizar.

**Diagramas C4:** Con respecto al diseñado de todos los diagramas C4 referentes a nuestro proyecto, siguiendo los esquemas necesarios y modelando todo para personas tanto técnicas como no técnicas en el área, nuestro grupo de trabajo ha decidido utilizar VisualParadigm, puesto que esta plataforma tiene modelos muy optimizados y especializados en el desarrollo de diagramas C4 en comparación a otros programas.

Página oficial de VisualParadigm: https://visual-paradigm.com/

**Diagrama UML:** Con respecto al diseñado de todos los diagramas UML referentes a nuestro proyecto, siguiendo los esquemas necesarios y modelando todo para programadores expertos, nuestro grupo de trabajo ha decidido utilizar LucidChart, puesto que esta es una plataforma especializada en el desarrollo de diagramas de este estilo, mostrando instrumentos adecuadas para toda la diagramación y separación de partes con grupos de trabajo.

Página oficial de LucidChart: https://lucidchart.com/

**Database Design:**  Con respecto al diseñado de la base de datos referente a nuestro proyecto, siguiendo los esquemas necesarios y modelando todo para nuestro equipo de gestión y desarrollo de bases de datos, nuestro grupo ha decidido utilizar la extensión ERD Editor de Visual Studio Code, debido a que esta extensión cumple con todos los requisitos necesarios para el diseñado de bases de datos y permite mostrar una versión en código directo con el uso de la IDE de Visual Studio, permitiendo un avance mucho más rápido, cómodo y completo de todo el trabajo que se debe realizar

Página oficial de Visual Studio Code: https://code.visualstudio.com/

Página de marketplace de ERD Editor de Visual Studio Code: https://marketplace.visualstudio.com/items?itemName=dineug.vuerd-vscode

---

#### Software Development:

Esta sección respecta a las herramientas y aplicaciones dadas para la programación de las páginas web correspondientes a la Landing Page y a la Web Applications de nuestro proyecto durante todo su ciclo de vida. Los instrumentos utilizados deben estar compuestos de IDEs, lenguajes de programación, bibliotecas y frameworks, puesto que deben seguir todos los principios y metodologías predispuestas en todo el proyecto, además de adecuarse a todas las historias de usuario, esquemas y diagramas planteados para cumplir los objetivos de nuestra startup y seguir todas las funcionalidades que buscan nuestros segmentos objetivos.

**Landing Page:** Con respecto al desarrollo de la landing page, se utilizaran varias herramientas para su programación y esquematización adecuada. Con respecto al lenguaje, se usara la combinación e implementación de HTML5, CSS3 y JavaScript, cada uno con su propia sección en archivo dentro del repositorio del grupo. El lenguaje de diseño utilizado debe basarse en el modelo del Material Design. Todo esto se usara debido a que estas herramientas son esenciales para la programación de páginas web adecuadas para un ambiente ya de producción.

**Frontend Web Application:** Con respecto al desarrollo del Frontend Web Application, se utilizaran varias herramientas para su programación y esquematización adecuada junto al diseñado conjunto con varios componentes. Se debe usar el Framework provisto por Vue para la facilitación de material de software y modelos de programación, junto al lenguaje producto de la combinación e implementación de HTML5, CSS3 y Javascript para el desarrollo de aspectos estáticos de templates. Javascript debe ser el principal lenguaje de programación durante el uso del código en la IDE. El lenguaje de diseño utilizado debe basarse en el modelo del Material Design. Asimismo, como biblioteca de materiales y componentes de UI se debe utilizar a PrimeVue para seguir los modelos de diseño del Framework de Vue y garantizar rápides y eficacia al momento de desplegar toda la aplicación web.

Página oficial de Visual Studio Code: https://code.visualstudio.com/

Página oficial de Vue.js: https://vuejs.org/

Página de especificación de Vue.js para la biblioteca de PrimeVue: https://primevue.org/

Página de guía y seguimiento para HTML5: https://www.w3schools.com/html/ 

Página de guía y seguimiento para CSS3: https://www.w3schools.com/css/default.asp

Página de guía y seguimiento para JavaScript: https://developer.mozilla.org/es/docs/Web/JavaScript

Página de guía y seguimiento para el modelo del Material Design: https://m3.material.io/

**Web Services:** Con respecto al desarrollo de los Web Services, se utilizaran varios modelos y metodologias prevista para la programación junto a frameworks con bibliotecas ya implementadas. El estilo de aplicación debe basarse en el RESTful API Architectural Style con el fin de mantener un Backend robusto y con comunicación rápida y directa, además de seguir modelos de buenas prácticas con más facilidad y seguridad. Junto al estilo dado, debe utilizarse el ASP.NET Core Framework junto a todos sus componentes, además de poder juntarlo y combinarlo adecuadamente con el lenguaje de programación de C# y así conseguir un estilo de programación más resistente y adecuado para nuestro backend. Con respecto a la documentación, se debe utilizar el modelo Swagger dado por OpenAPI Specification, puesto que es el modelo ideal en estos casos y permite un registro rápido ante nuevos cambios en la API en el entorno de desarrollo.

Página oficial de ASP.NET Core: https://dotnet.microsoft.com/es-es/apps/aspnet

Página oficial de Swagger: https://swagger.io/ 

Página de guía y seguimiento para C#: https://learn.microsoft.com/es-es/dotnet/csharp/ 

Página de guía y seguimiento para el modelo REST: https://es.apis.support.brightcove.com/getting-started/learning-guide-using-rest-apis.html

---

#### Software Testing:

Esta sección corresponde a las herramientas y aplicaciones dadas para la programación de modelos de testeo para todo el código que vamos a implementar, de forma que pueda garantizar el correcto funcionamiento de todas las clases, componentes, métodos de comunicación, etc. Los instrumentos utilizados deben estar basados en un programa sencillo o en una metodologia que permita la comprobación correcta de todas las funcionalidades de un código en varios escenarios distintos.

Como usamos el editor de codigo Visual Studio Code podremos hacer uso de la extension Live Server. Con esta extensión, tenemos la capacidad de configurar un servidor local, lo que nos facilita la visualización inmediata de las modificaciones que realizamos en un navegador web como Microsoft Edge o Chrome. De esta forma no perdemos tiempo al realizar compilaciones o depuraciones inmediatas. Asimismo, con respecto a las pruebas de aceptación, utilizaremos las herramientas brindadas por la extensión de Cucumber ofrecida también por Visual Studio Code, siguiendo el modelo del esquema Gherkin para garantizar una estructura funcional y ya ordenada.

Página de marketplace de Live Server de Visual Studio Code: https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer

Página de marketplace de Cucumber de Visual Studio Code: https://marketplace.visualstudio.com/items?itemName=CucumberOpen.cucumber-official

Guía de Cucumber para el modelo Gherkin: https://cucumber.io/docs/gherkin/

En caso en alguna sección del proyecto sea necesaria la implementación de pruebas automizadas para ganar tiempo y disminuir el gasto de recursos, vamos a utilizar el sistema de software de Cypress, el cual es un sistema bastante útil para pruebas inmediatas en frontend y para pruebas de regresión de aplicaciones web. De esta forma, podemos codificar soluciones de software que nos ayuden a revelar posibles errores en nuestras páginas web.

Página oficial de Cypress: https://www.cypress.io/ 

---

#### Software Deployment:

Esta sección corresponde a las herramientas y aplicaciones dadas para el despliegue e implementación adecuada de todas las páginas web que se programaran a lo largo de todo el ciclo de vida de nuestro proyecto. Los instrumentos utilizados deben ser sencillos de comprender y deben mostrar confianza y garantía al momento de desplegar todas las páginas para que así ninguna de estas se caiga por el mal rendimiento, o terminen saliendo con formatos distintos a los propuestos.

Para todo el despliegue necesario de la Landing Page, nuestro grupo va a utilizar el servicio dado de Github Pages, el cual otorga rendimiento rápido y garantía asegurada ante el uso de los repositorios que se encuentran en la misma plataforma. Asimismo, al ser una página estatica, la Landing Page no requiere muchos cambios y tampoco actualizaciones consecutivas y continuas. 

Página oficial de Github Pages: https://pages.github.com/ 

---

#### Software Document:

Esta sección corresponde a las herramientas y aplicaciones dadas para la documentación precisa de todo el reporte de programación junto a la propia documentación del software durante todo el ciclo de vida de nuestro proyecto. Las herramientas utilizadas para este proceso deben ser sencillas de comprender y manipular para todos los miembros del equipo, además de que deben ser adecuadas para el uso de textos largos con grandes cantidades de informcación, junto a soportar imagenes y seguir buenos modelos de división en secciones.

Para toda la documentación se utilizara un repositorio propio dentro de Github, el cual estara separado en varias ramas y se encontrara dentro de la propia organización del equipo de trabajo. Durante el proceso de escritura se debe usar el lenguaje de marcado de Markdown, de forma que se pueda garantizar la lectura en medios web a través de varios dispositivos y se pueda garantizar métodos de compresión y envio de data cifrada. Asimismo, con el fin de utilizar herramientas más especializadas, se usara el lenguaje HTML en ciertas secciones del desarrollo que no puedan ser escritas de forma cómoda y aceptable mediante Markdown, como, por ejemplo, las tablas de gran tamaño y división. 

Página oficial de Github: https://github.com/ 

Página de guía de uso de Markdown: https://www.markdownguide.org/ 

Página de guía y seguimiento para HTML5: https://www.w3schools.com/html/ 

---

### 5.1.2 Source Code Management.

En esta sección se establecerá la estrategia principal para utilizar GitHub como plataforma y sistema de control de versiones entre todas las colaboraciones dadas por el equipo de trabajo durante todo el ciclo de vida del proyecto. Es necesario utilizar todas las herramientas implementadas y estipuladas durante el uso del proyecto y seguir el historial de versiones para identificar posibles cambios nuevos o posibles errores que deben ser eliminados.

En nuestro caso se implementará el modelo GitFlow como WorkFlow de control de versiones, el cual incluye ramas principales como main y develop, las cuales funcionan como bases para el desarrollo e implementación final de todo un proyecto; así como ramas de características, lanzamiento y corrección, las cuales funcionan como ramas provisionales, las cuales tienen caracteristicas extras que esperan ser integradas en el producto final mediante un pull request dado por un miembro o por todo el equipo de trabajo. Esta estrategia proporciona una organización efectiva para el seguimiento de cambios, colaboración en el equipo y gestión de versiones del proyecto.

En esta sección explicaremos de qué forma se implementará GitFlow. Para este modelo presentado, cada Feature requiere su propio branch idealmente para luego ser integrado mediante un pull request ya establecido. Ante esta estrategia ya utilizada por nuestro equipo de trabajo, se explicaran y especificaran las convenciones que se deben aplicar para todos los titulos que llevaran las ramas creadas por nuestro equipo de trabajo:

| *Main: *Esta rama contendrá la versión estable del proyecto, lista para su despliegue.  |
|-----------------------------------------------------------------------------------------|

Develop: Aquí se agrupan todos los elementos en desarrollo. Una vez que el desarrollo está completo y se considera listo para avanzar al siguiente paso, se fusionará con la rama de lanzamiento (release).

Feature: Cada miembro del equipo trabajará en su propia rama individual, donde cargarán las secciones de código asignadas para una funcionalidad específica. Estas ramas de características se integrarán con la rama "develop".

Respecto a la convención para nombrar las ramas de características, se utilizará el formato siguiente:

| feature_<nombre -integrante>/<breve-descripción>    |
|-----------------------------------------------------|

Para nombrar las versiones de lanzamiento, se seguirá el versionado semántico 2.0.0, que consiste en la estructura 

| Mayor.Menor.Parche. |
|---------------------|

El último dígito (Parche) se refiere principalmente a corrección de errores compatibles con versiones anteriores..
El segundo dígito (Menor) aumenta cuando se añaden características compatibles con la versión anterior.
El primer dígito (Mayor) se incrementa para cambios significativos que podrían no ser compatibles con la versión anterior.

Por último, se adoptará el uso de Conventional Commits para los mensajes de texto en cada commit. La estructura de estos mensajes será:

| type: description |
|-------------------|

### 5.1.3 Source Code Style Guide & Conventions.

Se tiene la intención de seguir las directrices y normativas de codificación establecidas en una variedad de fuentes, tales como el HTML Style Guide and Coding Conventions, la Guía de Estilo de Codificación de Angular, la Guía de Estilo de Codificación para Java, las Convenciones Gherkin para Especificaciones Legibles, la Guía de Estilo de TypeScript, la Guía de Estilo de Codificación de Angular y las características específicas de Spring Boot.

**CONNVECIONES QUE USAREMOS**

HTML
- Usar nombres descriptivos para el archivo HTML
- Seguir una convención de nomenclatura consistente, como camelCase, para nombres de archivos y carpetas.
- Utiliza los elementos HTML de manera semántica para describir correctamente el contenido de tu sitio web. Esto incluye el uso apropiado de etiquetas.
- Mantener una estructura de código clara y legible mediante la indentación adecuada.
- Utilizar un estilo de formato consistente en todo el código para mejorar la mantenibilidad.

CSS
- Utiliza nombres de clases descriptivos y significativos para aplicar estilos a tus elementos HTML
- Prefiere nombres que reflejen la función o el propósito del elemento en lugar de su apariencia.
- Evita el uso de IDs para estilos, ya que pueden causar especificidad excesiva y dificultar la reutilización de estilos.

JavaScript:
- Para la nomenclatura se usara el camelCase para nombres de variables y funciones en JavaScript.
- Utiliza espacios o tabulaciones de manera consistente y asegúrate de mantener una línea de código por línea para mejorar la legibilidad.

TypeScript:
- Aprovecha las generics de TypeScript para crear funciones y clases que sean flexibles y reutilizables con diferentes tipos de datos.
- Usar el camelCase para nombres de variables y tipos, y el PascalCase para nombres de tipos de datos y clases.

Gherkin:
- Utiliza las palabras clave de Gherkin como Given, When, Then para estructurar tus escenarios de manera coherente y expresiva.

### 5.1.4 Software Deployment Configuration.

En esta sección especificaremos la configuración del despliegue de la solución, incluyendo los pasos necesarios para que, a partir de los repositorios de código fuente, se pueda lograr el despliegue de el Landing Page.

Empezaremos por crear un repositorio en GitHub para almacenar los archivos HTML, CSS y JavaScript. Luego cada integrante del equipo trabajará en su propia rama "feature" para desarrollar nuestro landing page. Una vez completada una característica, se procederá a hacer el merge con la rama "develop" para que la landing page se encuentre actualizada. estableceremos la configuración en GitHub Pages para publicar la página de destino utilizando la rama "develop". A continuación, detallamos los pasos para llevar a cabo este despliegue en GitHub Pages:

### 1. Comenzaremos creando un repositorio público en GitHub, le asignamos un nombre y añadimos los archivos necesarios.
<img src="/assets/img/set-repository-name.png" alt="Set Repository Name">
<img src="/assets/img/repository.png" alt="Repository">

### 2. Dirigirse a la sección de ajustes y elegir la pestaña Pages.

### 3. Nos dirigimos al apartado de configuración para GitHub Pages.

### 4. En el apartado de branch, seleccionamos el branch "main" donde se realizará el despliegue del landing page, dejando las demás configuraciones con sus valores predeterminados.
<img src="/assets/img/pagedeployed.png" alt="github page">

### 5. Al seleccionar la rama correspondiente, se generará un enlace que permitirá acceder al landing page. Cada modificación efectuada en el "main" se actualiza automáticamente.
<img src="/assets/img/github-link.png" alt="github link">

### 6. Finalmente, el landing estará desplegada, lista para ser visualizada y utilizada.
<img src="/assets/img/landing_deployed.png" alt="Landing deployed">

## 5.2 Landing Page, Services & Applications Implementation.

A continuacion explicaremos el enfoque que seguiremos para llevar a cabo la implementación, pruebas y lanzamiento de nuestro landing page, así como también de los servicios web y la interfaz de usuario de la aplicación web en cada ciclo de desarrollo. Con respecto al Sprint 1, nos centraremos únicamente en describir el proceso de implementación del landing page.

### 5.2.1 Sprint 1

### 5.2.1.1 Sprint Planning 1

El objetivo principal de esta reunión es establecer un plan claro y realista para el sprint, identificando las tareas a realizar y comprometiéndose con un conjunto de entregables concretos que contribuyan al avance del proyecto. A continuación, se presenta el resumen del Sprint Planning Meeting, que proporcionará una visión general de los temas discutidos y las decisiones tomadas durante la reunión.

| Sprint #                             | Sprint 1           |
|--------------------------------------|--------------------|
| Sprint Planning Background                                |
| Date                                 |  2024-04-01        |
| Time                                 |  04:06 PM          |
| Location                             |  Google Meet       |
| Prepared By                          |  Piero Tarazona    |
| Attendees (to planning meeting)      |  Piero Tarazona, Mauricio Chacon, Flavio Trigueros, Moises Donayre |
| Sprint 1 – 1 Review Summary          |  El Sprint 1 fue un éxito en términos de avance del producto de software y colaboración efectiva del equipo. Los logros alcanzados y la retroalimentación recopilada durante esta revisión proporcionan una base sólida para el siguiente sprint y refuerzan el compromiso del equipo con la calidad y la entrega oportuna del producto.  |
| Sprint 1 – 1 Retrospective Summary   |  Para la retrospectiva del Sprint 1 nos sirvio para reflexionar sobre el desempeño del equipo y identificar áreas de mejora. Esto nos servira como base para impulsar la mejora continua y optimizar el trabajo del equipo en los próximos sprints.  |
| Sprint Goal & User Stories                                |
| Sprint 1 Goal                        | Alcanzar una métrica de cumplimiento del 100%, lo que indicará que se ha logrado los objetivos del sprint 1              |
| Sprint 1 Velocity                    | Con el equipo para este sprint 1 decidimos aceptar 5 Story Points      |
| Sum of Story Points                  | La suma de los Story Points para los User Stories que se están incluyendo en este Sprint 1 es 32 |


### 5.2.1.2 Sprint Backlog 1

<table>
        <tr>
            <td colspan="2">Sprint #</td>
            <td colspan="6">Sprint 1</td>
        </tr>
        <tr>
            <td colspan="2">User Story</td>
            <td colspan="6">Work-Item / Task</td>
        </tr>
        <tr>
            <td>Id</td>
            <td>Title</td>
            <td>Id</td>
            <td>Title</td>
            <td>Descripcion</td>
            <td>Estimation (Hours)</td>
            <td>Assigned To</td>
            <td>Status (To-do / In / Process / ToReview / Done)</td>
        </tr>
        <tr>
            <td>US01</td>
            <td>Integración de Redes Sociales y Contenido Útil en el Footer</td>
            <td>T01</td>
            <td>Diseño del Footer</td>
            <td>Crear el diseño inicial del footer para integrar redes sociales y enlaces a contenido útil.</td>
            <td>40 minutos</td>
            <td>Mauricio</td>
            <td>Done</td>
        </tr>
        <tr>
            <td>US02</td>
            <td>Navegación eficiente a través de enlaces internos con anclas</td>
            <td>T02</td>
            <td> Implementación de Enlaces Internos con Anclas</td>
            <td>Implementar enlaces internos con anclas para una navegación más eficiente a través de secciones específicas de la página web.</td>
            <td>1 hora</td>
            <td>Moises</td>
            <td>Done</td>
        </tr>
        <tr>
            <td>US03</td>
            <td>Informacion de los planes que ofrecemos</td>
            <td>T03</td>
            <td>Creación de Sección de Planes de Suscripción</td>
            <td>Crear una sección para mostrar información detallada sobre los planes de suscripción ofrecidos, facilitando la comparación y elección por parte de los usuarios.</td>
            <td>1 hora</td>
            <td>Flavio</td>
            <td>Done</td>
        </tr>
        <tr>
            <td>US04</td>
            <td>Implementación de Sección de Contacto</td>
            <td>T04</td>
            <td>Integración de Sección de Contacto</td>
            <td>Integrar una sección "Contáctanos" con formulario para correo electrónico y número de teléfono, facilitando la comunicación rápida y sencilla con los usuarios.</td>
            <td>1 hora</td>
            <td>Piero</td>
            <td>Done</td>
        </tr>
        <tr>
            <td>US05</td>
            <td>Agregar la Sección "Sobre Nosotros"</td>
            <td>T05</td>
            <td>Agregacion de Sección "Sobre Nosotros"</td>
            <td>Agregar en el sitio web una sección "Sobre Nosotros" que proporcione información sobre nuestro objetivo, mejorando la comprensión de los usuarios sobre quiénes somos y qué hacemos.</td>
            <td>50 minutos</td>
            <td>Mauricio</td>
            <td>Done</td>
        </tr>
    </table>


### 5.2.1.3 Development Evidence for Sprint Review.

| Repository                        | Branch              | Commit Id                          | Commit Message                   | Commit Message Body           |Commited on (Date) |
|-----------------------------------|---------------------|------------------------------------|----------------------------------|-------------------------------|-------------------|
| REPOSITORIO DEL LANDING(NOMBRE)   | feature/loremipsum  | 14ca4e3                            | feat: ...                        | MENSAJE DEL COMMIT            | FECHA DEL COMMIT  |


### 5.2.1.4 Testing Suite Evidence for Sprint Review. 

| Repository                        | Branch              | Commit Id                          | Commit Message                   | Commit Message Body           |Commited on (Date) |
|-----------------------------------|---------------------|------------------------------------|----------------------------------|-------------------------------|-------------------|
| REPOSITORIO DEL LANDING(NOMBRE)   | feature/loremipsum  | 14ca4e3                            | feat: ...                        | MENSAJE DEL COMMIT            | FECHA DEL COMMIT  |

### 5.2.1.5 Execution Evidence for Sprint Review. 

En este punto explicaremos los logros alcanzados para el Sprint 1

-Creacion de repositorios para el report y el landing page en GitHub.
-Realizacion del wireframe y mock-ups del landing page.
-Realizacion del wireframe y mock-ups de la aplicacion web.
-Implementación del landing page.
-Diseño del prototipo de la aplicación web.
-Subir en el GitHub Pages el landing pages.

### 5.2.1.6 Services Documentation Evidence for Sprint Review. 

En este Sprint 1, realizamos el landing page donde no se hizo implementacion de algun servicio, por ese motivo es el que quedara vacio este punto.

### 5.2.1.7 Software Deployment Evidence for Sprint Review.

Explicaremos las acciones que realizamos en el sprint 1, como la preparacion y despliegue de nuestro landing page

* Primero creamos un repositorio en Github para el landing page
* 
* Las ramas necesarias se crean siguiendo el flujo de trabajo de GitFlow.
* 
* En la configuración del repositorio, se accede a la sección "Pages".
* 
* Se ajusta la configuración para indicar la fuente de la landing page.
* 
* Después de guardar la configuración, se genera un enlace para acceder a la landing page.
* 
* Este enlace permite visualizar las actualizaciones realizadas en la rama "develop".


### 5.2.1.8 Team Collaboration Insights during Sprint.

Para este Sprint 1, hemos hecho el desarrollo del landing page, colaborado en conjunto en la implementación. Esta colaboración se refleja en los distintos commits realizados en el repositorio, los cuales están documentados en las capturas de pantalla adjuntas.

Con respecto a la colaboracion del equipo, nos reunimos presencial como virtualmente para asignarnos tarea y discutir como elaborar el proyecto. Esto nos ha permitido comprender claramente nuestras responsabilidades individuales y tener un mejor desempeño. Para el desarrollo del código, hemos decidido que cada integrante se encarga de una sección específica del landing page. Esto para avanzar mas rapido y terminarlo antes de la entrega. Finalmente, tuvimos reuniones donde compartimos ideas y resolvemos algunas dudas o problemas que podriamos tener con respecto a la elaboracion del landing page, lo que nos dio resultados positivos en la elaboracion del trabajo.
